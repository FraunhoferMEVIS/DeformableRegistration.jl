        - 
        - function ngfDistance(referenceImage::Image,templateImage::Image,
        -                      transformedGrid::Array{Float64,1};
        - 		                 doDerivative=false,doHessian=false,
        - 		                 edgeParameterR=1,edgeParameterT=1,
        - 		                 debug=false,useEdgeParameterInNumerator=true)
        - 
        - 
       36     if(checkStaggered(referenceImage,transformedGrid))
        0       error("StaggeredGrids are not supported. Please transform to cell centered first.")
        -     end
        - 
        - 
        -     #c,dTtuple = linearInter2D(templateImage.data, 立T, mT, deformedGrid,doDerivative=doDerivative)
       36     if doDerivative
        1       transformedImage, dY_transformedImage, dX_transformedImage =
        -         linearImageInterpolationAtGridWithDerivative(templateImage,transformedGrid)
        1       dT = spdiagm((dY_transformedImage, dX_transformedImage),[0,prod(size(transformedImage))])
        - 
        -     else
       35       transformedImage =
        -         linearImageInterpolationAtGrid(templateImage,transformedGrid)
        -     end
        - 
        - 
        - 
       36     if debug==true
        0       @printf("\n\n edgeParameterR: %5e    edgeParameterT %5e \n", edgeParameterR, edgeParameterT)
        -     end
        - 
       36     m = size(referenceImage)
       36     h = referenceImage.properties["pixelspacing"]
       36     Rc = referenceImage.data
       36     立R = referenceImage.properties["spatialdomain"]
        - 
       36     shortFiniteDiffX = spdiagm((-ones(m[1]-1,1),ones(m[1]-2,1)),[0, 1],m[1]-1,m[1])/(2*h[1])
        -     #shortFiniteDiffX[1] = shortFiniteDiffX[2]
        -     #shortFiniteDiffX[end] = shortFiniteDiffX[end-1]
        - 
       36     shortFiniteDiffY = spdiagm((-ones(m[2]-1,1),ones(m[2]-2,1)),[0, 1],m[2]-1,m[2])/(2*h[2])
        -     #shortFiniteDiffY[1] = shortFiniteDiffY[2]
        -     #shortFiniteDiffY[end] = shortFiniteDiffY[end-1]
        - 
       36     averageX = spdiagm((0.5*ones(m[1]-2,1),0.5*ones(m[1]-1,1)),[-1, 0],m[1],m[1]-1)
       36     averageY = spdiagm((ones(m[2]-2,1)*0.5,ones(m[2]-1,1)*0.5),[-1, 0],m[2],m[2]-1)
        - 
       36     G1 = sparse(kron(speye(m[2]),shortFiniteDiffX));
       36     G2 = sparse(kron(shortFiniteDiffY,speye(m[1])));
        - 
       36     AvgX = sparse(kron(speye(m[2]),averageX));
       36     AvgY = sparse(kron(averageY,speye(m[1])));
        - 
       36     gradTx  = G1*transformedImage[:]
       36     gradTy  = G2*transformedImage[:]
        - 
       36     gradRx  = G1*Rc[:]
       36     gradRy =  G2*Rc[:]
        - 
       36     lengthGT = sqrt(sum(AvgX * (gradTx.^2) + AvgY * (gradTy.^2), 2) + edgeParameterT^2) #epsilon-norm
       36     lengthGR = sqrt(sum(AvgX * (gradRx.^2) + AvgY * (gradRy.^2), 2) + edgeParameterR^2)
        - 
       36     if useEdgeParameterInNumerator
       36       r1  = sum(AvgX * (gradRx.*gradTx) +
        - 		AvgY * (gradRy.*gradTy) ,2) .+ edgeParameterR*edgeParameterT    # numerator
        -     else
        0       r1  = sum(AvgX * (gradRx.*gradTx) +
        - 		AvgY * (gradRy.*gradTy) ,2)    # numerator
        -     end
       36     r2  = 1./(lengthGT.*lengthGR)             #  ... and denominator
       36     rc  = r1 .* r2                            # combine things and finalize
        - 
       36     dFunctionValue = 0
       36     d2FunctionValue = 0
       36     drc = 0
        - 
       36     if doDerivative
        1       dr1 = (AvgX * spdiagm(gradRx[:]) * G1) + (AvgY * spdiagm(gradRy[:]) * G2) #(AvgX * gradRx) * AvgX * G1 + (AvgY * gradRy) * AvgX * G2
        1       dr2 = ( spdiagm(-r2.^2)
        -               * spdiagm(lengthGR)
        -               * (spdiagm(1./(2 .* lengthGT)))
        -               * ((2 * AvgX * spdiagm(gradTx) * G1) + (2 * AvgY * spdiagm(gradTy) * G2))
        -             )
        - 
        -       #dr2Partial = reshape(  r1 .* -1 ./ (lengthGR .* lengthGT.^3)  ,(size(r1)))
        - 
        -       #drc = (    spdiag((r2 .* (AvgX * gradRx) + dr2Partial .* (AvgX * gradTx) )[:]) * AvgX * G1
        -       #         + spdiag((r2 .* (AvgY * gradRy) + dr2Partial .* (AvgY * gradTy) )[:]) * AvgY * G2 )
        1       drc = spdiagm(r1)*dr2 + spdiagm(r2) * dr1
        1       dFunctionValue  = -2*prod(h)*rc'*drc*dT;
        1       if doHessian
        1         d2FunctionValue =  2*prod(h) .* dT' * drc' * drc * dT   # note the missing minus sign is not a bug!
        -       end
        -     end
        - 
       36     functionValue  = prod(立R[2:2:end]-立R[1:2:end]) - prod(h) * (rc'*rc)
        - 
        -     #return functionValue[1], dFunctionValue', d2FunctionValue, r1, 1.-(rc.^2)
       36     return functionValue,dFunctionValue',d2FunctionValue, drc
        - 
        - 
        - end
        - 
